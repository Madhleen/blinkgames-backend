\n\n=== CONTROLLERS ===\n
import User from "../models/User.js";
import Order from "../models/Order.js";
import Raffle from "../models/Raffle.js";

// üîπ Dashboard geral (totais e m√©tricas)
export const getDashboard = async (req, res) => {
  try {
    const totalUsuarios = await User.countDocuments();
    const totalRifas = await Raffle.countDocuments({ ativo: true });
    const totalPagamentos = await Order.countDocuments({ status: "approved" });
    const receita = await Order.aggregate([
      { $match: { status: "approved" } },
      { $group: { _id: null, total: { $sum: "$total" } } },
    ]);

    res.json({
      totalUsuarios,
      totalRifas,
      totalPagamentos,
      receita: receita[0]?.total || 0,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao carregar dashboard." });
  }
};

// üîπ Listar usu√°rios
export const listUsers = async (req, res) => {
  try {
    const users = await User.find().select("-senhaHash -resetToken -resetTokenExp");
    res.json(users);
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usu√°rios." });
  }
};

// üîπ Listar rifas
export const listRaffles = async (req, res) => {
  try {
    const rifas = await Raffle.find().sort({ createdAt: -1 });
    res.json(rifas);
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar rifas." });
  }
};

// üîπ Listar pagamentos
export const listPayments = async (req, res) => {
  try {
    const pagamentos = await Order.find()
      .populate("userId", "nome email cpf")
      .populate("itens.raffleId", "titulo preco")
      .sort({ createdAt: -1 });
    res.json(pagamentos);
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar pagamentos." });
  }
};

// üîπ Exportar CSV (usu√°rios, rifas, pagamentos)
export const exportCSV = async (req, res) => {
  try {
    const tipo = req.query.tipo;

    let dados = [];
    if (tipo === "users") {
      dados = await User.find().select("nome email cpf telefone createdAt");
    } else if (tipo === "raffles") {
      dados = await Raffle.find().select("titulo preco ativo dataSorteio createdAt");
    } else if (tipo === "orders") {
      dados = await Order.find()
        .populate("userId", "nome email")
        .select("status total createdAt");
    } else {
      return res.status(400).json({ error: "Tipo inv√°lido para exporta√ß√£o." });
    }

    const csv = [
      Object.keys(dados[0].toObject()).join(","),
      ...dados.map((d) => Object.values(d.toObject()).join(",")),
    ].join("\n");

    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", `attachment; filename=${tipo}.csv`);
    res.send(csv);
  } catch (err) {
    res.status(500).json({ error: "Erro ao exportar CSV." });
  }
};
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import User from "../models/User.js";
import { validarCPF } from "../utils/cpf.js";
import { resetPasswordTemplate } from "../utils/emailTemplates.js";
import { transporter } from "../config/mailer.js";

const JWT_SECRET = process.env.JWT_SECRET;

// ============================================================
// üßç‚Äç‚ôÇÔ∏è Cadastro
// ============================================================
export const register = async (req, res) => {
  try {
    const nome = req.body.nome || req.body.name;
    const email = req.body.email?.toLowerCase();
    const senha = req.body.senha || req.body.password;
    const cpf = req.body.cpf;
    const telefone = req.body.telefone;

    if (!nome || !email || !senha) {
      return res.status(400).json({ error: "Preencha todos os campos obrigat√≥rios." });
    }

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ error: "Usu√°rio j√° existe." });
    }

    const hash = await bcrypt.hash(senha, 10);
    const user = new User({
      name: nome,
      email,
      password: hash,
      cpf,
      telefone,
    });

    await user.save();
    res.status(201).json({ message: "Usu√°rio cadastrado com sucesso!" });
  } catch (err) {
    console.error("‚ùå Erro no cadastro:", err);
    res.status(500).json({ error: "Erro ao registrar usu√°rio" });
  }
};

// ============================================================
// üîë Login
// ============================================================
export const login = async (req, res) => {
  try {
    const email = req.body.email?.toLowerCase();
    const senha = req.body.senha || req.body.password;

    if (!email || !senha) {
      return res.status(400).json({ error: "Preencha e-mail e senha." });
    }

    const user = await User.findOne({ email }).select("+password");
    if (!user) return res.status(404).json({ error: "Usu√°rio n√£o encontrado." });

    const isMatch = await bcrypt.compare(senha, user.password);
    if (!isMatch) return res.status(400).json({ error: "Email ou senha incorretos." });

    const token = jwt.sign(
      { id: user._id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: "7d" }
    );

    res.status(200).json({
      message: "Login realizado com sucesso!",
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
      },
    });
  } catch (err) {
    console.error("‚ùå Erro no login:", err);
    res.status(500).json({ error: "Erro ao fazer login" });
  }
};

// ============================================================
// ‚úâÔ∏è Esqueci minha senha
// ============================================================
export const forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ error: "Informe o e-mail." });

    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: "Usu√°rio n√£o encontrado." });

    // Gera token aleat√≥rio
    const token = crypto.randomBytes(32).toString("hex");
    user.resetToken = token;
    user.resetTokenExpires = Date.now() + 3600000; // expira em 1h
    await user.save();

    // Link de redefini√ß√£o
    const resetLink = `${process.env.BASE_URL_FRONTEND}/nova-senha.html?token=${token}`;

    // Monta o e-mail
    const mailOptions = {
      from: `"BlinkGames" <${process.env.SMTP_USER}>`,
      to: email,
      subject: "Redefini√ß√£o de senha - BlinkGames",
      html: resetPasswordTemplate(user.name || "usu√°rio", resetLink),
    };

    await transporter.sendMail(mailOptions);
    console.log(`üìß E-mail de redefini√ß√£o enviado para ${email}`);

    res.json({ message: "E-mail de redefini√ß√£o enviado com sucesso!" });
  } catch (err) {
    console.error("‚ùå Erro no esqueci minha senha:", err);
    res.status(500).json({ error: "Erro ao enviar e-mail de redefini√ß√£o." });
  }
};

// ============================================================
// üîê Redefinir senha
// ============================================================
export const resetPassword = async (req, res) => {
  try {
    const { token, newPassword } = req.body;
    if (!token || !newPassword)
      return res.status(400).json({ error: "Token e nova senha s√£o obrigat√≥rios." });

    const user = await User.findOne({
      resetToken: token,
      resetTokenExpires: { $gt: Date.now() },
    });

    if (!user)
      return res.status(400).json({ error: "Token inv√°lido ou expirado." });

    user.password = await bcrypt.hash(newPassword, 10);
    user.resetToken = undefined;
    user.resetTokenExpires = undefined;
    await user.save();

    res.json({ message: "Senha redefinida com sucesso!" });
  } catch (err) {
    console.error("‚ùå Erro ao redefinir senha:", err);
    res.status(500).json({ error: "Erro ao redefinir senha." });
  }
};

// ============================================================
// üí≥ BlinkGames ‚Äî checkoutController.js (v6.9 com external_reference = preferenceId)
// ============================================================

import { Preference } from "mercadopago";
import { client } from "../config/mercadoPago.js";
import Order from "../models/Order.js";

export const createCheckout = async (req, res) => {
  try {
    const { cart } = req.body;
    const userId = req.user?.id || "guest";

    if (!cart || !Array.isArray(cart) || cart.length === 0) {
      return res.status(400).json({ error: "Carrinho vazio ou inv√°lido" });
    }

    const items = cart.map((i) => ({
      title: i.title || "Produto BlinkGames",
      unit_price: Number(i.price) > 0 ? Number(i.price) : 1,
      quantity: Number(i.quantity) > 0 ? Number(i.quantity) : 1,
      currency_id: "BRL",
    }));

    const frontendURL = process.env.BASE_URL_FRONTEND || "https://blinkgamesrifa.vercel.app";
    const backendURL = process.env.BASE_URL_BACKEND || "https://blinkgames-backend-p4as.onrender.com";

    const preference = new Preference(client);
    const prefData = {
      items,
      back_urls: {
        success: `${frontendURL}/sucesso.html`,
        failure: `${frontendURL}/erro.html`,
        pending: `${frontendURL}/aguardando.html`,
      },
      auto_return: "approved",
      statement_descriptor: "BLINKGAMES",
      binary_mode: true,
      metadata: { userId, cart },
      notification_url: `${backendURL}/api/webhook/mercadopago`, // caminho principal
    };

    console.log("üü¶ Criando prefer√™ncia:", prefData);
    const response = await preference.create({ body: prefData });

    const preferenceId = response?.id || response?.body?.id || response?.body?.preference_id;
    const initPoint = response?.init_point || response?.body?.init_point;

    if (!preferenceId || !initPoint) {
      console.error("‚ùå Resposta inesperada do Mercado Pago:", response);
      return res.status(500).json({ error: "Falha ao gerar link de pagamento" });
    }

    // cria a Order j√° com preferenceId e userId correto
    const total = cart.reduce((acc, i) => acc + Number(i.price || 0) * Number(i.quantity || 1), 0);

    const newOrder = new Order({
      userId,
      mpPreferenceId: preferenceId,
      cart,
      total,
      status: "pending",
    });
    await newOrder.save();
    console.log("üóÉÔ∏è Order salva:", newOrder._id, "pref:", preferenceId);

    // Atualiza a prefer√™ncia para amarrar o external_reference ao pr√≥prio preferenceId
    try {
      await fetch(`https://api.mercadopago.com/checkout/preferences/${preferenceId}`, {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${process.env.MERCADOPAGO_ACCESS_TOKEN}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ external_reference: preferenceId }),
      });
      console.log("üîó external_reference definido:", preferenceId);
    } catch (e) {
      console.warn("‚ö†Ô∏è Falha ao setar external_reference:", e.message);
    }

    return res.status(200).json({ checkoutUrl: initPoint });
  } catch (err) {
    console.error("üí• Erro no checkout:", err);
    return res.status(500).json({
      error: err.response?.data?.message || err.message || "Falha desconhecida ao criar checkout",
    });
  }
};

import Order from "../models/Order.js";
import Raffle from "../models/Raffle.js";
import User from "../models/User.js";
import { gerarNumerosUnicos } from "../utils/numberGenerator.js";
import { client } from "../config/mercadoPago.js";
import { Preference } from "mercadopago";

// ============================================================
// üí≥ Criar ordem e preference no Mercado Pago
// ============================================================
export const createCheckout = async (req, res) => {
  try {
    const userId = req.user?.id;
    const { cart } = req.body; // [{ raffleId || id, qtd || quantity }]

    if (!userId || !cart || cart.length === 0) {
      return res.status(400).json({ error: "Carrinho vazio ou usu√°rio inv√°lido." });
    }

    // üîπ Busca usu√°rio no banco
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ error: "Usu√°rio n√£o encontrado." });
    }

    const itens = [];
    const orderItens = [];

    // üîπ Monta os itens da compra
    for (const item of cart) {
      const raffleId = item.raffleId || item.id || item._id;
      const qtd = item.qtd || item.quantity || 1;

      const rifa = await Raffle.findById(raffleId);
      if (!rifa) {
        console.warn("‚ö†Ô∏è Rifa n√£o encontrada:", raffleId);
        continue;
      }

      const numeros = gerarNumerosUnicos(qtd, rifa.maxNumeros, rifa.numerosVendidos);

      orderItens.push({
        raffleId: rifa._id,
        numeros,
        precoUnit: rifa.preco,
      });

      itens.push({
        title: rifa.titulo,
        quantity: Number(qtd),
        unit_price: Number(rifa.preco),
        currency_id: "BRL",
      });
    }

    if (orderItens.length === 0) {
      return res.status(400).json({ error: "Nenhuma rifa v√°lida encontrada." });
    }

    const total = orderItens.reduce(
      (sum, i) => sum + i.precoUnit * i.numeros.length,
      0
    );

    // ============================================================
    // üß† Cria√ß√£o da prefer√™ncia Mercado Pago
    // ============================================================
    const preference = new Preference(client);

    const payerData = {
      name: user.nome || "Cliente BlinkGames",
      email: user.email || "sem-email@blinkgames.com",
    };

    if (user.cpf) {
      payerData.identification = { type: "CPF", number: user.cpf };
    }

    console.log("üßæ Criando prefer√™ncia Mercado Pago...");

    const mpPreference = await preference.create({
      body: {
        items: itens,
        payer: payerData,
        metadata: { userId, cart: orderItens },
        back_urls: {
          success: `${process.env.BASE_URL_FRONTEND}/pagamento/sucesso`,
          failure: `${process.env.BASE_URL_FRONTEND}/pagamento/erro`,
          pending: `${process.env.BASE_URL_FRONTEND}/pagamento/pendente`,
        },
        auto_return: "approved",
        notification_url: `${process.env.BASE_URL_BACKEND}/api/webhooks/mercadopago`,
      },
    });

    if (!mpPreference?.id || !mpPreference?.init_point) {
      console.error("‚ùå Falha ao criar prefer√™ncia Mercado Pago:", mpPreference);
      return res.status(500).json({ error: "Erro ao criar prefer√™ncia no Mercado Pago." });
    }

    // ============================================================
    // üíæ Salva pedido no banco
    // ============================================================
    const order = new Order({
      userId,
      itens: orderItens,
      total,
      status: "pending",
      mpPreferenceId: mpPreference.id,
    });

    await order.save();

    console.log("‚úÖ Pedido salvo com sucesso:", order._id);

    res.json({ init_point: mpPreference.init_point });
  } catch (err) {
    console.error("‚ùå Erro ao criar checkout:", err);
    res.status(500).json({ error: err.message || "Erro ao criar checkout." });
  }
};

// ============================================================
// üì¶ Buscar ordens do usu√°rio logado
// ============================================================
export const getUserOrders = async (req, res) => {
  try {
    const orders = await Order.find({ userId: req.user.id }).sort({
      createdAt: -1,
    });
    res.json(orders);
  } catch (err) {
    console.error("‚ùå Erro ao buscar ordens:", err);
    res.status(500).json({ error: "Erro ao buscar ordens." });
  }
};

// ============================================================
// üéüÔ∏è BlinkGames ‚Äî raffleController.js (v6.8 FINAL ‚Äî alinhado ao modelo soldNumbers)
// ============================================================

import Raffle from "../models/Raffle.js";
import { gerarNumerosUnicos } from "../utils/numberGenerator.js";

// üîπ Listar rifas ativas (PS5 vem primeiro)
export const getRaffles = async (req, res) => {
  try {
    const rifas = await Raffle.find({ active: true });

    // Reordena para colocar o PS5 primeiro
    const ordenadas = rifas.sort((a, b) => {
      const aTitle = (a.title || a.titulo || "").toLowerCase();
      const bTitle = (b.title || b.titulo || "").toLowerCase();
      if (aTitle.includes("ps5")) return -1;
      if (bTitle.includes("ps5")) return 1;
      return 0;
    });

    res.json(ordenadas);
  } catch (err) {
    console.error("‚ùå Erro ao buscar rifas:", err);
    res.status(500).json({ error: "Erro ao buscar rifas" });
  }
};

// üîπ Detalhar uma rifa
export const getRaffleById = async (req, res) => {
  try {
    const rifa = await Raffle.findById(req.params.id);
    if (!rifa) return res.status(404).json({ error: "Rifa n√£o encontrada" });
    res.json(rifa);
  } catch (err) {
    console.error("‚ùå Erro ao buscar rifa:", err);
    res.status(500).json({ error: "Erro ao buscar rifa" });
  }
};

// üîπ Criar nova rifa (apenas admin)
export const createRaffle = async (req, res) => {
  try {
    const {
      titulo,
      descricao,
      imagem,
      preco,
      maxNumeros,
      dataSorteio,
      title,
      description,
      image,
      price,
      totalNumbers,
      drawDate,
      ativo,
    } = req.body;

    const novaRifa = new Raffle({
      title: title || titulo,
      description: description || descricao,
      image: image || imagem,
      price: price || preco,
      totalNumbers: totalNumbers || maxNumeros,
      drawDate: drawDate || dataSorteio,
      active: ativo ?? true,
      soldNumbers: [],
    });

    await novaRifa.save();
    res.status(201).json(novaRifa);
  } catch (err) {
    console.error("‚ùå Erro ao criar rifa:", err);
    res.status(500).json({ error: "Erro ao criar rifa" });
  }
};

// üîπ Atualizar rifa (admin)
export const updateRaffle = async (req, res) => {
  try {
    const updated = await Raffle.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
    });
    if (!updated)
      return res.status(404).json({ error: "Rifa n√£o encontrada" });
    res.json(updated);
  } catch (err) {
    console.error("‚ùå Erro ao atualizar rifa:", err);
    res.status(500).json({ error: "Erro ao atualizar rifa" });
  }
};

// üîπ Desativar rifa (admin)
export const deactivateRaffle = async (req, res) => {
  try {
    const updated = await Raffle.findByIdAndUpdate(
      req.params.id,
      { active: false },
      { new: true }
    );
    if (!updated)
      return res.status(404).json({ error: "Rifa n√£o encontrada" });
    res.json({ message: "Rifa desativada com sucesso!" });
  } catch (err) {
    console.error("‚ùå Erro ao desativar rifa:", err);
    res.status(500).json({ error: "Erro ao desativar rifa" });
  }
};

// üîπ Gerar n√∫meros dispon√≠veis (usado antes de comprar)
export const generateNumbers = async (req, res) => {
  try {
    const { id } = req.params;
    const { quantidade } = req.body;
    const rifa = await Raffle.findById(id);

    if (!rifa)
      return res.status(404).json({ error: "Rifa n√£o encontrada" });

    const numerosGerados = gerarNumerosUnicos(
      quantidade,
      rifa.totalNumbers,
      rifa.soldNumbers
    );

    res.json({ numeros: numerosGerados });
  } catch (err) {
    console.error("‚ùå Erro ao gerar n√∫meros:", err);
    res.status(500).json({ error: "Erro ao gerar n√∫meros" });
  }
};

// ============================================================
// üí≥ BlinkGames ‚Äî webhookController.js (v6.9 robusto)
// Aceita query (?topic=payment&id=...), aceita JSON,
// casa por external_reference (preferenceId) e faz fallback para a Order.
// ============================================================

import Order from "../models/Order.js";
import Raffle from "../models/Raffle.js";
import User from "../models/User.js";
import { client } from "../config/mercadoPago.js";
import { Payment } from "mercadopago";

export const handleMercadoPagoWebhook = async (req, res) => {
  try {
    // MP pode mandar via querystring OU JSON
    const body = typeof req.body === "string" ? JSON.parse(req.body) : (req.body || {});
    const topic = body?.type || body?.action || req.query?.topic || req.query?.type;
    const idFromBody = body?.data?.id || body?.id;
    const idFromQuery = req.query?.id;
    const paymentId = idFromBody || idFromQuery;

    // Ignoramos merchant_order (n√£o precisamos dele)
    if (String(topic).includes("merchant_order")) {
      return res.status(200).json({ ok: true, ignored: "merchant_order" });
    }

    if (!paymentId) {
      console.error("‚ö†Ô∏è Webhook sem ID:", { body, query: req.query });
      return res.status(400).json({ error: "Webhook sem ID de pagamento." });
    }

    console.log(`üì© Webhook recebido ‚Äî topic: ${topic || "?"} | ID: ${paymentId}`);

    // Busca pagamento no MP
    let payment;
    try {
      payment = await new Payment(client).get({ id: paymentId });
    } catch (err) {
      console.error("‚ö†Ô∏è Erro ao consultar pagamento no MP:", err.message);
      return res.status(400).json({ error: "Falha ao consultar pagamento no Mercado Pago." });
    }

    if (!payment || !payment.id) {
      console.error("‚ùå Pagamento n√£o encontrado no MP:", paymentId);
      return res.status(404).json({ error: "Pagamento n√£o encontrado." });
    }

    const status = payment.status;
    const metadata = payment.metadata || {};
    const ref = payment.external_reference || payment.order?.id; // preferenceId (o que atualizamos no checkout)
    console.log(`üí∞ Pagamento ${paymentId} (${status}) | ext_ref: ${ref}`);

    // Casa a Order pelo preferenceId salvo (ref)
    let order = null;
    if (ref) {
      order = await Order.findOne({ mpPreferenceId: ref });
    }
    // fallback extra: tenta por mpPaymentId
    if (!order) {
      order = await Order.findOne({ mpPaymentId: paymentId });
    }

    if (!order) {
      console.error("‚ùå Ordem n√£o encontrada para refer√™ncia:", ref);
      return res.status(404).json({ error: "Ordem n√£o encontrada." });
    }

    // Atualiza status e fixa id real do pagamento
    order.status = status;
    order.mpPaymentId = paymentId;
    await order.save();

    // Se aprovado, grava na rifa e no usu√°rio
    if (status === "approved") {
      const userId = metadata.userId || order.userId; // fallback se metadata n√£o veio
      const items =
        (Array.isArray(metadata.cart) && metadata.cart.length ? metadata.cart : order.cart) || [];

      if (!userId) {
        console.warn("‚ö†Ô∏è Sem userId para registrar compra. Order:", order._id);
      } else {
        const user = await User.findById(userId);
        if (user) {
          for (const item of items) {
            // atualiza rifa
            if (item.raffleId) {
              const raffle = await Raffle.findById(item.raffleId);
              if (raffle) {
                const nums = Array.isArray(item.numeros) ? item.numeros : [];
                raffle.numerosVendidos.push(...nums);
                await raffle.save();
              }
            }
            // registra no hist√≥rico do usu√°rio
            user.purchases.push({
              raffleId: item.raffleId,
              numeros: Array.isArray(item.numeros) ? item.numeros : [],
              precoUnit: Number(item.price) || Number(item.precoUnit) || 0,
              paymentId: String(paymentId),
              date: new Date(),
            });
          }
          await user.save();
          console.log(`üéüÔ∏è Compras vinculadas ao usu√°rio ${user.email} (order ${order._id})`);
        } else {
          console.warn("‚ö†Ô∏è Usu√°rio n√£o encontrado para userId:", userId);
        }
      }
    }

    console.log(`‚úÖ Webhook OK ‚Äî pagamento ${paymentId} (${status})`);
    return res.status(200).json({ ok: true });
  } catch (err) {
    console.error("üí• Erro inesperado no webhook:", err);
    return res.status(500).json({ error: "Erro ao processar webhook." });
  }
};

\n\n=== ROUTES ===\n
import express from "express";
import {
  getDashboard,
  listUsers,
  listRaffles,
  listPayments,
  exportCSV,
} from "../controllers/adminController.js";

import { createRaffle } from "../controllers/raffleController.js";
import { adminMiddleware } from "../middleware/admin.js";

const router = express.Router();

// üîπ Dashboard
router.get("/dashboard", adminMiddleware, getDashboard);

// üîπ Listagens
router.get("/users", adminMiddleware, listUsers);
router.get("/raffles", adminMiddleware, listRaffles);
router.get("/payments", adminMiddleware, listPayments);

// üîπ Exporta√ß√£o CSV
router.get("/export", adminMiddleware, exportCSV);

// üîπ Cria√ß√£o de rifas com chave admin
router.post("/rifas", adminMiddleware, createRaffle);

export default router;


import express from "express";
import {
  register,
  login,
  forgotPassword,
  resetPassword,
} from "../controllers/authController.js";

const router = express.Router();

// üßç Cadastro e Login
router.post("/register", register);
router.post("/login", login);

// ‚úâÔ∏è Recupera√ß√£o de senha
router.post("/forgot-password", forgotPassword);
router.post("/reset-password", resetPassword);

export default router;

// ============================================================
// üí≥ BlinkGames ‚Äî checkoutRoutes.js (v6.9 FINAL)
// ============================================================

import express from "express";
import { createCheckout } from "../controllers/checkoutController.js";

const router = express.Router();

// ============================================================
// üîπ Cria√ß√£o de checkout (rota principal)
// ============================================================
router.post("/", async (req, res, next) => {
  try {
    await createCheckout(req, res);
  } catch (err) {
    console.error("üí• Erro interno em /api/checkout:", err);
    next(err);
  }
});

// ============================================================
// üîé Healthcheck /debug opcional (√∫til pra Render testar rota)
// ============================================================
router.get("/", (req, res) => {
  res.status(200).json({ message: "‚úÖ Endpoint /api/checkout ativo" });
});

export default router;

import express from "express";
import { createCheckout, getUserOrders } from "../controllers/orderController.js";
import { authMiddleware } from "../middleware/auth.js";

const router = express.Router();

/**
 * @route POST /api/order/checkout
 * @desc Cria uma prefer√™ncia de pagamento no Mercado Pago
 * @access Privado (usu√°rio autenticado)
 */
router.post("/checkout", authMiddleware, createCheckout);

/**
 * @route GET /api/order/me
 * @desc Retorna todas as ordens do usu√°rio autenticado
 * @access Privado (usu√°rio autenticado)
 */
router.get("/me", authMiddleware, getUserOrders);

export default router;

import express from "express";
import {
  getRaffles,
  getRaffleById,
  createRaffle,
  updateRaffle,
  deactivateRaffle,
  generateNumbers,
} from "../controllers/raffleController.js";

import { authMiddleware } from "../middleware/auth.js";
import { adminMiddleware } from "../middleware/admin.js";

const router = express.Router();

// üîπ Rotas p√∫blicas
router.get("/", getRaffles);
router.get("/:id", getRaffleById);

// üîπ Rotas autenticadas e administrativas
router.post("/", authMiddleware, adminMiddleware, createRaffle);
router.put("/:id", authMiddleware, adminMiddleware, updateRaffle);
router.put("/:id/deactivate", authMiddleware, adminMiddleware, deactivateRaffle);

// üîπ Gerar n√∫meros dispon√≠veis (usu√°rio logado)
router.post("/:id/generate", authMiddleware, generateNumbers);

export default router;
// ============================================================
// üí≥ BlinkGames ‚Äî webhookRoutes.js (v6.4 Final Seguro)
// ============================================================

import express from "express";
import { handleMercadoPagoWebhook } from "../controllers/webhookController.js";

const router = express.Router();

// üîπ Rota p√∫blica oficial do Mercado Pago (POST)
router.post("/mercadopago", handleMercadoPagoWebhook);

// üî∏ Rota GET opcional ‚Äî √∫til pra testar no navegador
router.get("/mercadopago", (req, res) => {
  res.status(200).json({ message: "‚úÖ Webhook ativo e pronto para receber POST do Mercado Pago." });
});

// üî∏ Rota catch-all (opcional) ‚Äî evita 404 silencioso
router.all("*", (req, res) => {
  res.status(405).json({ error: "M√©todo n√£o permitido para este endpoint." });
});

export default router;

